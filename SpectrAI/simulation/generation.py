import math
import numpy as np
import pandas as pd
from tqdm import tqdm

##-\-\-\-\-\-\-\-\-\
## PRIVATE FUNCTIONS
##-/-/-/-/-/-/-/-/-/

# -------------------------------------------
# Calculate the absorbance of a given mixture
def _absorbance_mix(
    molecule_list: list,
    concentration_list: list,
    wv_name: str = 'wavelength (nm)', coeff_name: str = ' K (L/mol)', abs_name: str = 'A (a.u.)'
    ):

    """_absorbance_mix function
------------------------
Function to mix two molecules

Input(s):
- molecule_list {list of pd.DataFrame}: List of the extinction coefficient of the molecules.
- concentration_list {list of float}: List of concentrations to use for the molecules.
                                      Should have the same size as molecule_list.
- wv_name, coeff_name, abs_name {str}: (Opt.) Name of the column to use to read and save the
                                       dataframe.
                                       Default: 'wavelength (nm)', ' K (L/mol)', and 'A (a.u.)'
    
Output(s):
- absorbance {pd.Series}: Dataframe of mixed molecules.
"""

    # NOTE: Need to add lines to check the inputs

    # Calculate the absorbance
    absorbance_values = molecule_list[0][coeff_name]*concentration_list[0]
    for i in range(len(molecule_list[1:])):
        absorbance_values += molecule_list[i+1][coeff_name]*concentration_list[i+1]

    # Generate the absorbance dataframe
    absorbance = pd.DataFrame({
        wv_name : molecule_list[0][wv_name],
        abs_name : absorbance_values
        })

    return absorbance

# ------------------------------------------------------------
# Process the dataframe to extract the extinction coefficients
def _dataframe_processing(
    dataframe_list: list,
    coeff_name: str = ' K (L/mol)'
    ):
        
    """_dataframe_processing function
------------------------------
Function to process the dataframe and output processed data 

Input(s):
- dataframe_list {list}: A list containing all the dataframes of the molecules.
- coeff_name {str}: (Opt.) Name of the column to use to read and save the
                    dataframe.
                    Default: ' K (L/mol)'
                       
Output(s):
- max_ext list}: Maximum extinction coefficient of each molecule.
- max_ext_wavelength {list}: Corresponding wavelength to each maximum extinction coefficient.
"""

    # Initialise the lists
    max_ext, max_ext_wavelength = [], []

    # Process all the dataframes available
    for molecule in dataframe_list:

        # Get the row ID of the maximum extinction coefficient
        max_id = molecule[coeff_name].idxmax()

        # Get the wavelength and maximum extinction coefficient
        mol_wv_max, mol_max_ext = molecule.iloc[max_id].values

        # Populate the lists
        max_ext.append(mol_max_ext)
        max_ext_wavelength.append(mol_wv_max)

    return max_ext, max_ext_wavelength

# ---------------------
# Generate sensor noise
def _generate_sensor_noise(
    absorbance: np.ndarray,
    min_err: float = 0.005, max_err: float = 0.02
    ):

  """_generate_sensor_noise function
-------------------------------
Function to emulate the noise generated by the sensor while reading
a sample. Based on experimental data

Input(s):
- absorbance {NumPy array}: Absorbance values to generate noise for.
- min_err {float}: (Opt.) Error at high light intensity.
                   Default (from experiments): 0.005 (0.5%)
- max_err {float}: (Opt.) Error at low light intensity.
                   Default (from experiments): 0.02 (2%)

Output(s):
- abs_noise {NumPy array}: Input absorbances, with noise added to it
"""

  # Define the conversion parameters
  # from experiments - do not change
  i0 = 45000 # Assume a constant light source over the wavelength
  min_intensity = 3000
  max_intensity = 45000

  # Calculate the intensity from the absorbance
  intensity = i0 / 10**(absorbance)

  # Rescale the intensity to an error factor
  normalized_intensity = (intensity - min_intensity)/(max_intensity - min_intensity)
  error_factor = normalized_intensity * (min_err - max_err) + max_err

  # Calculate the noise
  noise = np.random.normal(0, error_factor)

  # Convert back to absorbance
  int_noise = intensity * (1 + noise)
  abs_noise = np.log10( i0 / int_noise )

  return abs_noise

##-\-\-\-\-\-\-\-\
## PUBLIC FUNCTIONS
##-/-/-/-/-/-/-/-/

# ------------------------------------------------------
# Rescale the concentrations to match the absorbance max
def concentrationScaling(
    molecule_list: list,
    a_max: float = 0.9,
    wv_name: str = 'wavelength (nm)', coeff_name: str = ' K (L/mol)', abs_name: str = 'A (a.u.)'
    ): 
    
    """concentrationScaling function
-----------------------------
Function to rescale absorbance for a given mix of molecules if it goes above
the absorbance max.

Input(s):
- molecule_list {list of pd.DataFrame}: List of the extinction coefficient of the molecules.
- a_max {float}: (Opt.) Define the maximum absorbance that should not be exceeded.
                 Default: 0.9
- wv_name, coeff_name, abs_name {str}: (Opt.) Name of the column to use to read and save the
                                       dataframe.
                                       Default: 'wavelength (nm)', ' K (L/mol)', and 'A (a.u.)'

Output(s):
- concentration_list {list of float}: List of max concentrations to use for the molecules.
"""

    # Create lists with max ext coefficients and the wavelengths corresponding to max ext coeffs.
    max_extinction_list, _ = _dataframe_processing(molecule_list, coeff_name=coeff_name)

    # Calculate Max concentration for individual molecules
    cmax_list = []
    for max_ext in max_extinction_list:
        cmax_list.append( a_max/max_ext )
    
    # Calculate the absorbance
    absorbance_max = _absorbance_mix(molecule_list, cmax_list, wv_name=wv_name, coeff_name=coeff_name, abs_name=abs_name)
    
    # If conditional to rescale if condition met
    if absorbance_max[abs_name].max() > a_max: 

        revision_factor = a_max / absorbance_max[abs_name].max()
        cmax_to_revise = cmax_list.copy()
        cmax_list = []

        for cmax in cmax_to_revise:
            cmax_list.append( cmax * revision_factor )
    
    return cmax_list # Returns scaled concentrations

# -------------------------------------------
# Create a single mixture between N molecules
def createMixture(
    molecule_list: list,
    concentration_list: list,
    c_error: float = 0.05, s_noise: tuple = (0.005, 0.02),
    wv_name: str = 'wavelength (nm)', coeff_name: str = ' K (L/mol)', abs_name: str = 'A (a.u.)'
    ):

    """createMixture function
----------------------
Function to generate all possible mixtures between two molecules.

Input(s):
- molecule_list {list of pd.DataFrame}: List of the extinction coefficient of the molecules.
- concentration_list {list of float}: List of concentrations to use for the molecules.
                                      Should have the same size as molecule_list.
- c_error {float}: (Opt.) Average concentration in error added to each molecules
                   while preparing a mixture.
                   Default: 0.05 (5%)
- s_noise {tuple of float}: (Opt.) Error at high and low light intensity.
                            Default: (0.005, 0.02), obtained through experimental measurement.
- wv_name, coeff_name, abs_name {str}: (Opt.) Name of the column to use to read and save the
                                       dataframe.
                                       Default: 'wavelength (nm)', ' K (L/mol)', and 'A (a.u.)'

Output(s):
- mix {pd.Dataframe}: Absorbance spectrum of the mixture
- concentration_error {list of float}: Actual concentrations (incl. eventual errors)
                                       used to generate the mixture.
- errors {list of float}: Values of the errors used for the sample generation.
"""

    # NOTE: Need to add lines to check the inputs

    # Recompute the concentration if needed
    concentration_error = []
    for c in concentration_list:
        if c_error != 0:
            concentration_error.append( c * (1 + np.random.normal(0, c_error)) )
        else:
            concentration_error.append( c )

    # Make the mixture
    mix = _absorbance_mix(molecule_list, concentration_error, wv_name=wv_name, coeff_name=coeff_name, abs_name=abs_name)

    # Add the sensor noise if needed
    if s_noise[0] != 0 and s_noise[1] != 0:
        mix[abs_name] = _generate_sensor_noise(mix[abs_name], min_err=s_noise[0], max_err=s_noise[1])

    return mix, concentration_error, [c_error, s_noise[0], s_noise[1]]

# ----------------------------------
# Generate a sample for CNN training
def generateSamples(
    molecule_list: list,
    molecule_names: list,
    concentration_list: list,
    n_concentrations: int = 5,
    n_samples: int = 10000,
    c_error: float = 0.005, s_noise: tuple = (0.005, 0.02),
    wv_name: str = 'wavelength (nm)', coeff_name: str = ' K (L/mol)', abs_name: str = 'A (a.u.)',
    verbose: bool = False
    ):

    """generateSamples function
------------------------
Function to generate all possible mixtures between two molecules.

Input(s):
- molecule_list {list of pd.DataFrame}: List of the extinction coefficient of the molecules.
- molecule_names {list of str}: List of the names of the molecules used for the data generation.
- concentration_list {list of float}: List of concentrations to use for the molecules.
                                      Should have the same size as molecule_list.
- n_concentrations {int}: Number of concentration per molecules to use for the sample.
                          Lowest concentration will always be set to 0,
                          Highest concentration will always be set to concentration max.
                          Default: 5
- n_samples {int}: Total number of samples to generate for the training.
                   Should be a multiple of n_concentrations ** n_molecules
                   Default: 10000
- c_error {float}: (Opt.) Average concentration in error added to each molecules
                   while preparing a mixture.
                   Default: 0.005 (0.5%)
- s_noise {tuple of float}: (Opt.) Error at high and low light intensity.
                            Default: (0.005, 0.02), obtained through experimental measurement.
- wv_name, coeff_name, abs_name {str}: (Opt.) Name of the column to use to read and save the
                                       dataframe.
                                       Default: 'wavelength (nm)', ' K (L/mol)', and 'A (a.u.)'
- verbose {bool}: (Opt.) Toggle verbose mode on or off.
                  Default: False (not verbose)
                       
Output(s):
- all_samples {list of pd.Dataframe}: List of absorbance spectra of all the mixtures
- all_names {list of str}: List of all the molecule names used for the mixtures
- all_concentrations {list of float}: Set concentrations (excl. eventual errors)
                                      used to generate the mixtures.
- all_conc_with_errors {list of float}: Actual concentrations (incl. eventual errors)
                                        used to generate the mixtures.
- error_values {list of float}: Values of the errors used for the sample generation.
"""

    # Calculate the number of samples per mixture
    n_samples_per_mixture = n_samples / (n_concentrations ** len(molecule_list))

    # Adjust if needed so the real number of samples >= n_samples
    if n_samples_per_mixture - int(n_samples_per_mixture) != 0:
        n_samples_per_mixture = math.ceil(n_samples_per_mixture)
        if verbose:
            print('WARNING: The value of n_samples ('+str(n_samples)+') cannot be used for the data generation. Using '+str(n_samples_per_mixture * n_concentrations ** len(molecule_list) )+' samples instead.')
    n_samples_per_mixture = int(n_samples_per_mixture)

    # Prepare all the possible concentrations to use for the data generation
    all_mixtures_concentrations = []
    for cmax in concentration_list:

        # Make the list of concentration to use
        crt_conc_list = [ cmax * i/(n_concentrations - 1) for i in range(n_concentrations) ]

        # Initialise the list
        if len(all_mixtures_concentrations) == 0:
            for c in crt_conc_list:
                all_mixtures_concentrations.append([c])
        
        else:

            prev_mix_conc = all_mixtures_concentrations.copy()
            all_mixtures_concentrations = []

            for prev_c in prev_mix_conc:
                for c in crt_conc_list:
                    all_mixtures_concentrations.append( prev_c + [c] )
    
    # Generate all the data
    all_samples = []
    all_names = []
    all_concentrations = []
    all_conc_with_errors = []

    for crt_concentrations in tqdm(all_mixtures_concentrations, desc='Mixture generation...', disable=not verbose):

        # Generate multiple data from the same mixture
        for i in range(n_samples_per_mixture):

            # Make the mixture
            new_mixture, conc_error, error_values = createMixture(molecule_list,
                                                                    crt_concentrations,
                                                                    c_error=c_error, s_noise=s_noise,
                                                                    wv_name=wv_name, coeff_name=coeff_name, abs_name=abs_name
                                                                    )

            # Save to the structure
            all_samples.append( new_mixture )
            all_names.append( molecule_names )
            all_concentrations.append( crt_concentrations )
            all_conc_with_errors.append( conc_error )

    return all_samples, all_names, all_concentrations, all_conc_with_errors, error_values
